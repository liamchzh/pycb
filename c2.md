第二章 文件
==========
引言
----
Python中，文件对象是内建类型file的实例。内建函数open会创建并返回一个文件对象。  

    input = open('data', 'r')
    output = open('/tmp/spam', 'w')

完成处理后应该调用close方法来完成收尾工作，关闭所有和这个文件对象的联系。  
写入文件的时候，使用write方法：

    output.write(s)

readline方法可以从一个文本文件中读取并返回一行文本数据。但是还有更好的方式，在python中，可以对这个文件对象执行一个循环，每次获得一行文本并处理：

    for line in input:
        process(line)

2.1 读取文件
-----------
最方便的方法是一次性读取所有的内容到一个大字符串中：

    all_the_text = open('thefile.txt').read()
    all_the_data = open('abinfile', 'rb').read()

也可以逐行读取，这样读出的每行文本末尾都有'\n'符号：

    lists_of_all_the_lines = file_object.readlines()

如果不想这样，还可以：

    list_of_all_the_lines = file_object.read().splitlines()
    list_of_all_the_lines = file_object.read().split('\n')
    list_of_all_the_lines = [L.rstrip('\n') for L in file_object]

在类UNIX系统中，文本文件和二进制文件其实没有什么区别。但是在Windows下，换行符不是'\n'，而是'\r\n'和'\r'。所以当你打开的是二进制文件是，就要告诉python，这样它就不会做任何简化。  
如果不确定文件会用什么样的换行符，可以将open函数的第二个参数设置为'rU'，指定通用换行符，这样在Windows,UNIX和Mac下就完全没有问题。  
  
如果只需要读取文件的一小部分，方式就不同了：

    file_object = open('abinfile', 'rb')
    try:
        while True:
            chunk = file_object.read(100) #读100个字节
            if not chunk:
                break
            do_something_with(chunk)
    finally:
        file_object.close()

对于上述例子，还可以封装成可以复用的生成器，但是yield不能用在try语句中，所以要抛弃try/finally语句对文件关闭的保护。

    def read_file_by_chunks(filename, chunksize=100):
        file_object = open(filename, 'rb')
        while True:
            chunk = file_object.read(chunksize)
            if not chunk:
                break
            yield chunk
        file_object.close()

2.2 写入文件
-----------
直接上代码：

    file_object = open('thefile.txt', 'w')
    file_object.write(all_the_text)
    file_object.close()

如果写入的数据在一个字符串列表中，应该使用writelines方法，对于二进制文件和文本文件都适用：

    file_object.writelines(list_of_text_strings)
    open('abinfile', 'rb').writelines(list_of_data_strings)

注意，当用'w'或'wb'打开一个文件准备写入数据的时候，文件中原有的数据将被清除。


