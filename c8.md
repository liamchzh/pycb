第8章 调试和测试
================
8.1 阻止某些条件和循环的执行
---------------------------
调试的时候，希望某些条件或循环部分的代码可以暂时忽略。  
最简单的办法是插入`0: #`  

    if i < 1:
        dosth()
    while j < k:
        dosth()

改成：

    if 0: # i < 1:
        dosth()
    while 0: # j < k:
        dosth()

也可以定义一个布尔变量，假设`doit = Flase`:  

    if doit and i < 1:
        dosth()
    while doit and j < k:
        dosth()

这种方法可以快速地切换：`doit = True`。调试结束后别忘了移除。  

8.2 在Linux上测量内存使用
-------------------------
想监控运行在Linux上的程序究竟占了多少内存，然后标准库模块resource并不能在Linux中正确地工作。  
可以基于Linux的/proc伪文件系统编写我们的测量程序：

    import os
    _proc_status = '/proc/%d/status' % os.getpid()
    _scale = {'kB':1024.0, 'mB':1024.0 * 1024.0, 'KB':1024.0, 'MB':1024.0 * 1024.0}
    def _Vmb(VmKey):
        '''给定VmKey字符串，返回字节数'''
        try:
            t = open(_proc_status)
            v = t.read()
            t.close()
        except IOError:
            return 0.0
        i = v.index(Vmkey)
        v = v[i:].split(None, 3)
        if len(v) < 3:
            return 0.0
        return float(v[1]) * _scale[v[2]]
    def memory(since=0.0):
        return _Vmb("VmSize:") - since
    def resident(since=0.0):
        return _Vmb('VmRSS:') - since
    def stacksize(since=0.0):
        return _Vmb('VmStk:') - since

8.3 调试垃圾回收进程
---------------------
借助gc模块。可以获得更多信息来定位例如内存泄漏之类的bug。  

    import gc 
    def dump_garbage():
        print "\nGARBAGE:"
        gc.collect()
        print "\nGARBAGE OBJECTS:"
        for x in gc.garbage:
            s = str(x):
            print type(x),"\n",s

    if __name__ == "__main__":
        gc.enable()
        gc.set_debug(gc.DEBUG_LEAK)
        #模拟一个泄漏
        l = []
        l.append(l)
        del l
        dump_garbage()

8.4 捕获和记录异常
------------------

